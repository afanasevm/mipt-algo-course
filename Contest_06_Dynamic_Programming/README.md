# Contest 6: Dynamic Programming

This folder contains my solutions for the Dynamic Programming (DP) contest. It covers a wide range of DP techniques, from basic 1D/2D arrays to DP on bitmasks and broken profiles.

## Tasks:
* **A.cpp** - Minimum steps to break a chocolate bar into 1x1 pieces.
* **B.cpp** - Placing `m` wells among `n` houses to minimize the total walking distance.
* **C.cpp** - The classic "Egg Dropping" problem: finding the minimum number of drops to test `k` crystal balls from `n` floors.
* **D.cpp** - Longest Common Subsequence (LCS) of two strings.
* **E.cpp** - Classic 0-1 Knapsack problem.
* **F.cpp** - Knapsack problem with an extra rule: all chosen items must have different colors.
* **G.cpp** - Counting valid sets of numbers that sum up to a given `n`.
* **I.cpp** - String algorithms using Edit distance and Hamming distance.
* **K.cpp** - Longest Non-Increasing Subsequence.
* **L.cpp & M.cpp** - Longest Alternating Subsequences (finding a "ladder" pattern in an array).
* **N.cpp** - Longest Common Increasing Subsequence (LCIS).
* **O.cpp** - Counting the total number of distinct subsequences in an array.
* **P.cpp & Q.cpp** - Counting paths on a 2D grid with specific movement rules and boundaries (Combinatorics and DP).
* **R.cpp** - Finding the cheapest Hamiltonian path (Traveling Salesperson Problem) using Bitmask DP.
* **S.cpp & T.cpp** - DP on broken profile (DP on grid states). Filling a grid with characters so that every 2x2 square matches specific rules.
* **U.cpp** - Counting the number of cliques in a graph using DP / Meet-in-the-middle.
