# Contest 8: Shortest Paths and Spanning Trees

This folder contains my solutions for finding shortest paths and Minimum Spanning Trees (MST) in graphs. 

## Tasks:
* **A.cpp** - Classic Dijkstra's algorithm for finding shortest paths in a graph with non-negative weights.
* **B.cpp** - Multi-source BFS to simulate virus spreading, combined with finding the safest and fastest path for a person.
* **C.cpp** - Finding the cheapest path that fits within a given time limit (Dijkstra with 2 parameters / 2D states).
* **D.cpp** - Ford-Bellman algorithm for finding shortest paths in a graph that can contain negative edge weights.
* **E.cpp** - Finding a negative weight cycle in a directed graph using the Ford-Bellman algorithm.
* **F.cpp** - Finding optimal routes using shortest paths algorithms considering mood changes (edge weights) and mandatory stops.
* **G.cpp** - Finding the transitive closure of a directed graph (Floyd-Warshall algorithm / DFS).
* **H.cpp** - Solving the "8-puzzle" game (sliding tiles) in the minimum number of moves using BFS on the implicit state graph, with path restoration.
* **J.cpp** - Finding the shortest path in a skyscraper with elevators and teleports (Dijkstra on a complex graph).
* **L.cpp** - Offline processing of edge removals and connectivity queries using Disjoint Set Union (DSU) by processing queries in reverse order.
* **M.cpp** - Finding the Minimum Spanning Tree (MST) of a weighted undirected graph (Kruskal's / Prim's algorithm).
* **N.cpp** - Finding the cheapest way to share knowledge among lecturers and hire them to cover all topics (MST with virtual/dummy vertex).
