# Contest 4: Search Trees

This folder contains my solutions for the fourth contest. The main focus is on Binary Search Trees (BST), balanced trees, and their applications.

## Tasks:
* **A.cpp** - Building a Cartesian Tree (Treap) in O(N) time given an array sorted by keys.
* **B.cpp** - Implementing an AVL tree from scratch to support adding elements and finding the `lower_bound` (next element).
* **C.cpp** - A custom dictionary (Key-Value storage) implemented using a balanced Binary Search Tree (without using `std::map`).
* **D.cpp** - Implementing a Cartesian Tree (Treap) from scratch with standard operations (insert, delete, find).
* **E.cpp** - Finding the minimum fuel tank capacity to complete different routes using binary search and `std::set` to manage charging stations.
* **F.cpp** - A balanced Search Tree that supports finding the sum of all elements in a given range `[L, R]`.
* **G.cpp** - Simulating the splitting and merging of street segments using a balanced Search Tree (Treap) with implicit keys to maintain the order and lengths of segments.
* **I.cpp** - 2D Range Queries: finding the number of elements in a subsegment `[l, r]` whose values fall within the range `[x, y]`, with point updates.
